const express = require('express');
const TelegramBot = require('node-telegram-bot-api');
const bodyParser = require('body-parser');
const cors = require('cors');
const mysql = require('mysql2');
const path = require('path');

// 1. –í–°–¢–ê–í–¨ –°–í–û–ô –¢–û–ö–ï–ù –°–Æ–î–ê
const token = '8005167313:AAFu5AxIB2Itfhdgr6peM7rip0HGUieJmkc';
// 2. ID –ê–¥–º–∏–Ω–æ–≤ (–º–æ–∂–Ω–æ —É–¥–∞–ª—è—Ç—å –ª—é–±—ã–µ –±—Ä–æ–Ω–∏)
const ADMIN_IDS = ['299696306', 'YOUR_ID_2']; // –ó–∞–º–µ–Ω–∏—Ç–µ –Ω–∞ —Ä–µ–∞–ª—å–Ω—ã–µ ID

const bot = new TelegramBot(token, { polling: true });

// Handle polling errors gracefully
bot.on('polling_error', (error) => {
    // Only log specific error types to avoid spam
    if (error.code === 'EFATAL') {
        console.error('[Telegram Bot] Connection error - retrying...', error.message);
    } else {
        console.error('[Telegram Bot] Polling error:', error.code || error.message);
    }
});

const app = express();
const PORT = 3000;

// Setup MySQL Connection Pool
const pool = mysql.createPool({
    host: 'localhost',
    user: 'root',
    password: '',
    database: 'dorm_app',
    waitForConnections: true,
    connectionLimit: 10,
    queueLimit: 0,
    timezone: '+00:00' // Force UTC
});

// Test connection
pool.getConnection((err, connection) => {
    if (err) {
        console.error('Error connecting to MySQL:', err.message);
    } else {
        console.log('Connected to the MySQL database.');
        connection.release();
        initDb();
    }
});

function initDb() {
    const usersTable = `
        CREATE TABLE IF NOT EXISTS users (
            telegram_id VARCHAR(255) PRIMARY KEY,
            username TEXT,
            first_name TEXT,
            photo_url TEXT,
            language_code VARCHAR(10) DEFAULT 'en',
            updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
        )
    `;

    const bookingsTable = `
        CREATE TABLE IF NOT EXISTS bookings (
            id INT AUTO_INCREMENT PRIMARY KEY,
            user_id VARCHAR(255),
            username TEXT,
            first_name TEXT,
            photo_url TEXT,
            date VARCHAR(255),
            slot_time VARCHAR(255),
            end_time VARCHAR(255),
            floor VARCHAR(10) DEFAULT '3',
            comment TEXT,
            notified BOOLEAN DEFAULT 0,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP
        )
    `;

    const gatheringsTable = `
        CREATE TABLE IF NOT EXISTS gatherings (
            id INT AUTO_INCREMENT PRIMARY KEY,
            title TEXT,
            time VARCHAR(255),
            description TEXT,
            created_by VARCHAR(255),
            user_id VARCHAR(255),
            first_name TEXT,
            user_photo TEXT,
            image_url TEXT,
            likes_count INT DEFAULT 0,
            comments_count INT DEFAULT 0,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP
        )
    `;

    const gatheringLikesTable = `
        CREATE TABLE IF NOT EXISTS gathering_likes (
            id INT AUTO_INCREMENT PRIMARY KEY,
            gathering_id INT,
            user_id VARCHAR(255),
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
            UNIQUE KEY unique_like (gathering_id, user_id),
            FOREIGN KEY (gathering_id) REFERENCES gatherings(id) ON DELETE CASCADE
        )
    `;

    const gatheringCommentsTable = `
        CREATE TABLE IF NOT EXISTS gathering_comments (
            id INT AUTO_INCREMENT PRIMARY KEY,
            gathering_id INT,
            user_id VARCHAR(255),
            username TEXT,
            first_name TEXT,
            photo_url TEXT,
            comment TEXT,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (gathering_id) REFERENCES gatherings(id) ON DELETE CASCADE
        )
    `;

    const feedbackTable = `
        CREATE TABLE IF NOT EXISTS reviews (
            id INT AUTO_INCREMENT PRIMARY KEY,
            user_id VARCHAR(255),
            username TEXT,
            first_name TEXT,
            photo_url TEXT,
            category VARCHAR(50),
            message TEXT,
            likes_count INT DEFAULT 0,
            comments_count INT DEFAULT 0,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP
        )
    `;

    const commentsTable = `
        CREATE TABLE IF NOT EXISTS review_comments (
            id INT AUTO_INCREMENT PRIMARY KEY,
            review_id INT,
            user_id VARCHAR(255),
            username TEXT,
            first_name TEXT,
            photo_url TEXT,
            comment TEXT,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (review_id) REFERENCES reviews(id) ON DELETE CASCADE
        )
    `;

    const likesTable = `
        CREATE TABLE IF NOT EXISTS review_likes (
            id INT AUTO_INCREMENT PRIMARY KEY,
            review_id INT,
            user_id VARCHAR(255),
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
            UNIQUE KEY unique_like (review_id, user_id),
            FOREIGN KEY (review_id) REFERENCES reviews(id) ON DELETE CASCADE
        )
    `;

    pool.query(usersTable);
    pool.query(bookingsTable);
    pool.query(gatheringsTable);
    pool.query(gatheringLikesTable);
    pool.query(gatheringCommentsTable);
    pool.query(feedbackTable);
    pool.query(commentsTable);
    pool.query(likesTable);
}

app.use(cors());
app.use(bodyParser.json({ limit: '50mb' }));
app.use(bodyParser.urlencoded({ limit: '50mb', extended: true }));
app.use(express.static('public'));

// --- Helpers (Promisified for Transaction) ---

function query(connection, sql, params) {
    return new Promise((resolve, reject) => {
        connection.query(sql, params, (err, result) => {
            if (err) return reject(err);
            resolve(result);
        });
    });
}

function checkOverlap(connection, date, start, end, floor) {
    return query(connection, "SELECT * FROM bookings WHERE date = ? AND floor = ?", [date, floor])
        .then(rows => {
            return rows.some(row => {
                const existingStart = row.slot_time;
                const existingEnd = row.end_time || row.slot_time;
                return start < existingEnd && end > existingStart;
            });
        });
}

function insertBooking(connection, data) {
    const sql = 'INSERT INTO bookings (user_id, username, first_name, photo_url, date, slot_time, end_time, floor, comment) VALUES (?,?,?,?,?,?,?,?,?)';
    const params = [data.user_id, data.username, data.first_name, data.photo_url, data.date, data.slot_time, data.end_time, data.floor, data.comment];
    return query(connection, sql, params);
}

function upsertUser(connection, user) {
    const sql = `
        INSERT INTO users (telegram_id, username, first_name, photo_url, language_code) 
        VALUES (?, ?, ?, ?, ?) 
        ON DUPLICATE KEY UPDATE 
            username=VALUES(username), 
            first_name=VALUES(first_name), 
            photo_url=VALUES(photo_url),
            language_code=VALUES(language_code),
            updated_at=CURRENT_TIMESTAMP
    `;
    return query(connection, sql, [user.user_id, user.username, user.first_name, user.photo_url, user.language_code || 'en']);
}

// Helper: Get Warsaw date string
function getWarsawDate() {
    const warsawNow = new Date(new Date().toLocaleString('en-US', { timeZone: 'Europe/Warsaw' }));
    const year = warsawNow.getFullYear();
    const month = String(warsawNow.getMonth() + 1).padStart(2, '0');
    const day = String(warsawNow.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
}

// --- API Endpoints ---

// Sync user data on app startup (updates language and other info)
app.post('/api/user/sync', (req, res) => {
    const { user_id, username, first_name, photo_url, language_code } = req.body;
    // console.log(`[SYNC] User: ${username} (${user_id}), Lang: ${language_code}`);

    if (!user_id) {
        return res.status(400).json({ "error": "Missing user_id" });
    }

    pool.getConnection(async (err, connection) => {
        if (err) {
            return res.status(500).json({ "error": "DB Connection Failed" });
        }

        try {
            // 1. Update user in users table
            await upsertUser(connection, { user_id, username, first_name, photo_url, language_code });

            if (!date || !slot_time || !end_time) {
                return res.status(400).json({ "error": "Missing required fields" });
            }

            // Validation: Past Date (Warsaw timezone UTC+1)
            const today = getWarsawDate();
            console.log(`[DEBUG] Booking date: ${date}, Warsaw today: ${today} `);
            if (date < today) {
                console.log(`[DEBUG] Rejected: ${date} < ${today}`);
                return res.status(400).json({ "error": "–ù–µ–ª—å–∑—è –±—Ä–æ–Ω–∏—Ä–æ–≤–∞—Ç—å –≤ –ø—Ä–æ—à–ª–æ–º!" });
            }

            // Get Connection for Transaction
            pool.getConnection(async (err, connection) => {
                if (err) {
                    return res.status(500).json({ "error": "DB Connection Failed" });
                }

                try {
                    // 1. Start Transaction
                    await query(connection, 'START TRANSACTION');

                    // 2. Get Lock (Wait 5s)
                    const lockRes = await query(connection, "SELECT GET_LOCK('booking_lock', 5) AS locked");
                    if (!lockRes[0].locked) {
                        throw new Error("Server busy, try again");
                    }

                    // 3. Upsert User with language_code
                    await upsertUser(connection, { user_id, username, first_name, photo_url, language_code });

                    // 4. Booking Logic
                    if (end_time < slot_time) {
                        // Cross-day
                        const nextDateObj = new Date(date);
                        nextDateObj.setDate(nextDateObj.getDate() + 1);
                        const nextDate = nextDateObj.toISOString().split('T')[0];

                        const overlap1 = await checkOverlap(connection, date, slot_time, "24:00", floor);
                        const overlap2 = await checkOverlap(connection, nextDate, "00:00", end_time, floor);

                        if (overlap1 || overlap2) {
                            await query(connection, 'ROLLBACK');
                            return res.status(409).json({ "error": "–ü–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ —Å –¥—Ä—É–≥–æ–π –±—Ä–æ–Ω—å—é!" });
                        }

                        await insertBooking(connection, { user_id, username, first_name, photo_url, date, slot_time, end_time: "24:00", floor, comment: comment + " (–ß–∞—Å—Ç—å 1)" });
                        await insertBooking(connection, { user_id, username, first_name, photo_url, date: nextDate, slot_time: "00:00", end_time, floor, comment: comment + " (–ß–∞—Å—Ç—å 2)" });

                        res.json({ "message": "success", "crossDay": true });

                    } else {
                        // Normal
                        const hasOverlap = await checkOverlap(connection, date, slot_time, end_time, floor);
                        if (hasOverlap) {
                            await query(connection, 'ROLLBACK');
                            return res.status(409).json({ "error": "–≠—Ç–æ –≤—Ä–µ–º—è —É–∂–µ –∑–∞–Ω—è—Ç–æ!" });
                        }

                        await insertBooking(connection, { user_id, username, first_name, photo_url, date, slot_time, end_time, floor, comment });
                        res.json({ "message": "success" });
                    }

                    // 5. Commit
                    await query(connection, 'COMMIT');

                } catch (error) {
                    await query(connection, 'ROLLBACK');
                    console.error("Transaction Error:", error);
                    res.status(500).json({ "error": error.message || "Internal Server Error" });
                } finally {
                    // 6. Release Lock & Connection
                    await query(connection, "SELECT RELEASE_LOCK('booking_lock')");
                    connection.release();
                }
            });
        });

    app.put('/api/bookings/:id', (req, res) => {
        const bookingId = req.params.id;
        const userId = req.headers['x-user-id'];
        const { slot_time, end_time, comment } = req.body;

        if (!userId) return res.status(401).json({ "error": "Unauthorized" });
        if (!slot_time || !end_time) return res.status(400).json({ "error": "Missing fields" });

        pool.getConnection(async (err, connection) => {
            if (err) return res.status(500).json({ "error": "DB Connection Failed" });

            try {
                await query(connection, 'START TRANSACTION');

                // 1. Get existing booking
                const rows = await query(connection, 'SELECT * FROM bookings WHERE id = ? FOR UPDATE', [bookingId]);
                if (rows.length === 0) {
                    await query(connection, 'ROLLBACK');
                    return res.status(404).json({ "error": "Booking not found" });
                }

                const booking = rows[0];

                // 2. Check ownership
                if (String(booking.user_id) !== String(userId) && !ADMIN_IDS.includes(String(userId))) {
                    await query(connection, 'ROLLBACK');
                    return res.status(403).json({ "error": "–ù–µ—Ç –ø—Ä–∞–≤" });
                }

                // 3. Validate Shrink-Only Constraint
                if (slot_time < booking.slot_time || end_time > booking.end_time) {
                    await query(connection, 'ROLLBACK');
                    return res.status(400).json({ "error": "–ú–æ–∂–Ω–æ —Ç–æ–ª—å–∫–æ —É–º–µ–Ω—å—à–∏—Ç—å –≤—Ä–µ–º—è –±—Ä–æ–Ω–∏!" });
                }

                // --- Smart Cross-Day Logic ---
                if (booking.end_time === "24:00" && end_time < "24:00") {
                    const dateObj = new Date(booking.date);
                    dateObj.setDate(dateObj.getDate() + 1);
                    const nextDate = dateObj.toISOString().split('T')[0];

                    const part2Rows = await query(connection,
                        'SELECT id FROM bookings WHERE user_id = ? AND date = ? AND slot_time = "00:00"',
                        [userId, nextDate]
                    );

                    if (part2Rows.length > 0) {
                        await query(connection, 'DELETE FROM bookings WHERE id = ?', [part2Rows[0].id]);
                        console.log(`[Smart Update] Deleted Part 2(ID: ${part2Rows[0].id}) because Part 1 was shortened.`);
                    }
                }
                // -----------------------------

                // 4. Update
                await query(connection, 'UPDATE bookings SET slot_time = ?, end_time = ?, comment = ? WHERE id = ?',
                    [slot_time, end_time, comment, bookingId]);

                await query(connection, 'COMMIT');
                res.json({ "message": "Updated successfully" });

            } catch (error) {
                await query(connection, 'ROLLBACK');
                console.error(error);
                res.status(500).json({ "error": "Internal Server Error" });
            } finally {
                connection.release();
            }
        });
    });

    app.delete('/api/bookings/:id', (req, res) => {
        const bookingId = req.params.id;
        const userId = req.headers['x-user-id'];

        if (!userId) {
            return res.status(401).json({ "error": "Unauthorized" });
        }

        // 1. Check ownership
        pool.query('SELECT user_id FROM bookings WHERE id = ?', [bookingId], (err, rows) => {
            if (err) return res.status(500).json({ "error": err.message });
            if (rows.length === 0) return res.status(404).json({ "error": "Booking not found" });

            const booking = rows[0];
            const isOwner = String(booking.user_id) === String(userId);
            const isAdmin = ADMIN_IDS.includes(String(userId));

            if (!isOwner && !isAdmin) {
                return res.status(403).json({ "error": "–£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ —É–¥–∞–ª—è—Ç—å —ç—Ç—É –±—Ä–æ–Ω—å" });
            }

            // 2. Delete
            pool.query('DELETE FROM bookings WHERE id = ?', [bookingId], (err) => {
                if (err) return res.status(500).json({ "error": err.message });
                res.json({ "message": "deleted" });
                console.log(`Booking ${bookingId} deleted by ${userId} `);
            });
        });
    });

    app.get('/api/gatherings', (req, res) => {
        const userId = req.headers['x-user-id'];
        const sql = `
        SELECT g.*,
                EXISTS(SELECT 1 FROM gathering_likes WHERE gathering_id = g.id AND user_id = ?) as user_liked
        FROM gatherings g
        ORDER BY g.created_at DESC
    `;
        pool.query(sql, [userId], (err, rows) => {
            if (err) {
                res.status(400).json({ "error": err.message });
                return;
            }
            res.json({ "data": rows });
        });
    });

    app.post('/api/gatherings', (req, res) => {
        const { title, time, description, created_by, user_id, first_name, user_photo, image_url } = req.body;
        console.log('[POST /api/gatherings] Received:', { title, time, user_id, first_name, has_image: !!image_url });

        const sql = 'INSERT INTO gatherings (title, time, description, created_by, user_id, first_name, user_photo, image_url) VALUES (?,?,?,?,?,?,?,?)';
        const params = [title, time, description, created_by, user_id, first_name, user_photo, image_url];
        pool.query(sql, params, function (err, result) {
            if (err) {
                console.error('[POST /api/gatherings] Error:', err.message);
                res.status(400).json({ "error": err.message });
                return;
            }
            console.log('[POST /api/gatherings] Success, ID:', result.insertId);
            res.json({
                "message": "success",
                "data": req.body,
                "id": result.insertId
            });
        });
    });

    // Update gathering (only owner)
    app.put('/api/gatherings/:id', (req, res) => {
        const gatheringId = req.params.id;
        const userId = req.headers['x-user-id'];
        const { title, time, description, image_url } = req.body;

        pool.query('SELECT user_id FROM gatherings WHERE id = ?', [gatheringId], (err, rows) => {
            if (err) return res.status(400).json({ "error": err.message });
            if (rows.length === 0) return res.status(404).json({ "error": "Not found" });
            if (rows[0].user_id != userId) return res.status(403).json({ "error": "Not authorized" });

            const sql = 'UPDATE gatherings SET title = ?, time = ?, description = ?, image_url = ? WHERE id = ?';
            pool.query(sql, [title, time, description, image_url, gatheringId], (err) => {
                if (err) return res.status(400).json({ "error": err.message });
                res.json({ "message": "updated" });
            });
        });
    });

    // Delete gathering (only owner)
    app.delete('/api/gatherings/:id', (req, res) => {
        const gatheringId = req.params.id;
        const userId = req.headers['x-user-id'];

        pool.query('SELECT user_id FROM gatherings WHERE id = ?', [gatheringId], (err, rows) => {
            if (err) return res.status(400).json({ "error": err.message });
            if (rows.length === 0) return res.status(404).json({ "error": "Not found" });
            if (rows[0].user_id != userId) return res.status(403).json({ "error": "Not authorized" });

            pool.query('DELETE FROM gatherings WHERE id = ?', [gatheringId], (err) => {
                if (err) return res.status(400).json({ "error": err.message });
                res.json({ "message": "deleted" });
            });
        });
    });

    // Like/Unlike gathering
    app.post('/api/gatherings/:id/like', (req, res) => {
        const gatheringId = req.params.id;
        const userId = req.headers['x-user-id'];

        if (!userId) return res.status(401).json({ "error": "Unauthorized" });

        pool.query('SELECT * FROM gathering_likes WHERE gathering_id = ? AND user_id = ?', [gatheringId, userId], (err, rows) => {
            if (err) return res.status(500).json({ "error": err.message });

            if (rows.length > 0) {
                pool.query('DELETE FROM gathering_likes WHERE gathering_id = ? AND user_id = ?', [gatheringId, userId], (err) => {
                    if (err) return res.status(500).json({ "error": err.message });
                    pool.query('UPDATE gatherings SET likes_count = likes_count - 1 WHERE id = ?', [gatheringId]);
                    res.json({ "message": "unliked" });
                });
            } else {
                pool.query('INSERT INTO gathering_likes (gathering_id, user_id) VALUES (?,?)', [gatheringId, userId], (err) => {
                    if (err) return res.status(500).json({ "error": err.message });
                    pool.query('UPDATE gatherings SET likes_count = likes_count + 1 WHERE id = ?', [gatheringId]);
                    res.json({ "message": "liked" });
                });
            }
        });
    });

    // Get comments for gathering
    app.get('/api/gatherings/:id/comments', (req, res) => {
        const gatheringId = req.params.id;
        pool.query('SELECT * FROM gathering_comments WHERE gathering_id = ? ORDER BY created_at ASC', [gatheringId], (err, rows) => {
            if (err) return res.status(500).json({ "error": err.message });
            res.json({ "data": rows });
        });
    });

    // Add comment to gathering
    app.post('/api/gatherings/:id/comments', (req, res) => {
        const gatheringId = req.params.id;
        const { user_id, username, first_name, photo_url, comment } = req.body;

        if (!comment) return res.status(400).json({ "error": "Comment is required" });

        const sql = 'INSERT INTO gathering_comments (gathering_id, user_id, username, first_name, photo_url, comment) VALUES (?,?,?,?,?,?)';
        pool.query(sql, [gatheringId, user_id, username, first_name, photo_url, comment], (err, result) => {
            if (err) return res.status(500).json({ "error": err.message });
            pool.query('UPDATE gatherings SET comments_count = comments_count + 1 WHERE id = ?', [gatheringId]);
            res.json({ "message": "success", "id": result.insertId });
        });
    });

    // Update gathering comment (only owner)
    app.patch('/api/gathering-comments/:id', (req, res) => {
        const commentId = req.params.id;
        const userId = req.headers['x-user-id'];
        const { comment } = req.body;

        if (!userId) return res.status(401).json({ "error": "Unauthorized" });

        pool.query('SELECT user_id FROM gathering_comments WHERE id = ?', [commentId], (err, rows) => {
            if (err) return res.status(500).json({ "error": err.message });
            if (rows.length === 0) return res.status(404).json({ "error": "Comment not found" });

            if (String(rows[0].user_id) !== String(userId)) {
                return res.status(403).json({ "error": "Forbidden" });
            }

            pool.query('UPDATE gathering_comments SET comment = ? WHERE id = ?', [comment, commentId], (err) => {
                if (err) return res.status(500).json({ "error": err.message });
                res.json({ "message": "updated" });
            });
        });
    });

    // Delete gathering comment (only owner)
    app.delete('/api/gathering-comments/:id', (req, res) => {
        const commentId = req.params.id;
        const userId = req.headers['x-user-id'];

        if (!userId) return res.status(401).json({ "error": "Unauthorized" });

        pool.query('SELECT user_id, gathering_id FROM gathering_comments WHERE id = ?', [commentId], (err, rows) => {
            if (err) return res.status(500).json({ "error": err.message });
            if (rows.length === 0) return res.status(404).json({ "error": "Comment not found" });

            if (String(rows[0].user_id) !== String(userId)) {
                return res.status(403).json({ "error": "Forbidden" });
            }

            const gatheringId = rows[0].gathering_id;

            pool.query('DELETE FROM gathering_comments WHERE id = ?', [commentId], (err) => {
                if (err) return res.status(500).json({ "error": err.message });

                // Decrease comments count
                pool.query('UPDATE gatherings SET comments_count = comments_count - 1 WHERE id = ?', [gatheringId]);

                res.json({ "message": "deleted" });
            });
        });
    });

    setInterval(() => {
        const warsawNow = new Date(new Date().toLocaleString('en-US', { timeZone: 'Europe/Warsaw' }));
        const currentDate = getWarsawDate();

        // Find bookings starting in 15 minutes
        const futureTime = new Date(warsawNow.getTime() + 15 * 60000);
        const futureHour = String(futureTime.getHours()).padStart(2, '0');
        const futureMinute = String(futureTime.getMinutes()).padStart(2, '0');
        const targetTime = `${futureHour}:${futureMinute} `;

        pool.query(
            'SELECT * FROM bookings WHERE date = ? AND slot_time = ? AND notified = 0',
            [currentDate, targetTime],
            (err, rows) => {
                if (err) return console.error('Notification check error:', err);

                rows.forEach(booking => {
                    bot.sendMessage(
                        booking.user_id,
                        `üéÆ –ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ!\n\n–¢–≤–æ—è –±—Ä–æ–Ω—å PS Zone –Ω–∞—á–Ω–µ—Ç—Å—è —á–µ—Ä–µ–∑ 15 –º–∏–Ω—É—Ç(${booking.slot_time}).\n\n–£—Å–ø–µ–π –ø—Ä–∏–π—Ç–∏! üïπÔ∏è`
                    ).then(() => {
                        pool.query('UPDATE bookings SET notified = 1 WHERE id = ?', [booking.id]);
                        console.log(`Notification sent to ${booking.username} for booking at ${booking.slot_time} `);
                    }).catch(err => console.error('Send message error:', err));
                });
            }
        );
    }, 60000); // Every minute

    // --- Reviews API ---
    app.post('/api/reviews', (req, res) => {
        const { user_id, username, first_name, photo_url, category, message } = req.body;

        if (!message || !category) {
            return res.status(400).json({ "error": "Missing required fields" });
        }

        // Check if user already has 3 reviews
        pool.query('SELECT COUNT(*) as count FROM reviews WHERE user_id = ?', [user_id], (err, rows) => {
            if (err) return res.status(500).json({ "error": err.message });

            if (rows[0].count >= 3) {
                return res.status(400).json({ "error": "–í—ã —É–∂–µ –æ—Å—Ç–∞–≤–∏–ª–∏ –º–∞–∫—Å–∏–º—É–º –æ—Ç–∑—ã–≤–æ–≤ (3)" });
            }

            const sql = 'INSERT INTO reviews (user_id, username, first_name, photo_url, category, message) VALUES (?,?,?,?,?,?)';
            pool.query(sql, [user_id, username, first_name, photo_url, category, message], (err, result) => {
                if (err) return res.status(500).json({ "error": err.message });
                res.json({ "message": "success", "id": result.insertId });
            });
        });
    });

    app.get('/api/reviews', (req, res) => {
        const userId = req.headers['x-user-id'];

        // Everyone sees all reviews
        const sql = `
        SELECT r.*,
                EXISTS(SELECT 1 FROM review_likes WHERE review_id = r.id AND user_id = ?) as user_liked
        FROM reviews r
        ORDER BY r.created_at DESC
    `;

        pool.query(sql, [userId], (err, rows) => {
            if (err) return res.status(500).json({ "error": err.message });
            res.json({ "data": rows });
        });
    });

    // Like/Unlike review
    app.post('/api/reviews/:id/like', (req, res) => {
        const reviewId = req.params.id;
        const userId = req.headers['x-user-id'];

        if (!userId) {
            return res.status(401).json({ "error": "Unauthorized" });
        }

        // Check if already liked
        pool.query('SELECT * FROM review_likes WHERE review_id = ? AND user_id = ?', [reviewId, userId], (err, rows) => {
            if (err) return res.status(500).json({ "error": err.message });

            if (rows.length > 0) {
                // Unlike
                pool.query('DELETE FROM review_likes WHERE review_id = ? AND user_id = ?', [reviewId, userId], (err) => {
                    if (err) return res.status(500).json({ "error": err.message });
                    pool.query('UPDATE reviews SET likes_count = likes_count - 1 WHERE id = ?', [reviewId]);
                    res.json({ "message": "unliked" });
                });
            } else {
                // Like
                pool.query('INSERT INTO review_likes (review_id, user_id) VALUES (?,?)', [reviewId, userId], (err) => {
                    if (err) return res.status(500).json({ "error": err.message });
                    pool.query('UPDATE reviews SET likes_count = likes_count + 1 WHERE id = ?', [reviewId]);
                    res.json({ "message": "liked" });
                });
            }
        });
    });

    // Get comments for a review
    app.get('/api/reviews/:id/comments', (req, res) => {
        const reviewId = req.params.id;

        pool.query('SELECT * FROM review_comments WHERE review_id = ? ORDER BY created_at ASC', [reviewId], (err, rows) => {
            if (err) return res.status(500).json({ "error": err.message });
            res.json({ "data": rows });
        });
    });

    // Add comment to review
    app.post('/api/reviews/:id/comments', (req, res) => {
        const reviewId = req.params.id;
        const { user_id, username, first_name, photo_url, comment } = req.body;

        if (!comment) {
            return res.status(400).json({ "error": "Comment is required" });
        }

        const sql = 'INSERT INTO review_comments (review_id, user_id, username, first_name, photo_url, comment) VALUES (?,?,?,?,?,?)';
        pool.query(sql, [reviewId, user_id, username, first_name, photo_url, comment], (err, result) => {
            if (err) return res.status(500).json({ "error": err.message });

            // Update comments count
            pool.query('UPDATE reviews SET comments_count = comments_count + 1 WHERE id = ?', [reviewId]);

            res.json({ "message": "success", "id": result.insertId });
        });
    });

    // Update comment (only owner)
    app.patch('/api/comments/:id', (req, res) => {
        const commentId = req.params.id;
        const userId = req.headers['x-user-id'];
        const { comment } = req.body;

        if (!userId) return res.status(401).json({ "error": "Unauthorized" });

        pool.query('SELECT user_id FROM review_comments WHERE id = ?', [commentId], (err, rows) => {
            if (err) return res.status(500).json({ "error": err.message });
            if (rows.length === 0) return res.status(404).json({ "error": "Comment not found" });

            if (String(rows[0].user_id) !== String(userId)) {
                return res.status(403).json({ "error": "Forbidden" });
            }

            pool.query('UPDATE review_comments SET comment = ? WHERE id = ?', [comment, commentId], (err) => {
                if (err) return res.status(500).json({ "error": err.message });
                res.json({ "message": "updated" });
            });
        });
    });

    // Delete comment (only owner)
    app.delete('/api/comments/:id', (req, res) => {
        const commentId = req.params.id;
        const userId = req.headers['x-user-id'];

        if (!userId) return res.status(401).json({ "error": "Unauthorized" });

        pool.query('SELECT user_id, review_id FROM review_comments WHERE id = ?', [commentId], (err, rows) => {
            if (err) return res.status(500).json({ "error": err.message });
            if (rows.length === 0) return res.status(404).json({ "error": "Comment not found" });

            if (String(rows[0].user_id) !== String(userId)) {
                return res.status(403).json({ "error": "Forbidden" });
            }

            const reviewId = rows[0].review_id;

            pool.query('DELETE FROM review_comments WHERE id = ?', [commentId], (err) => {
                if (err) return res.status(500).json({ "error": err.message });

                // Decrease comments count
                pool.query('UPDATE reviews SET comments_count = comments_count - 1 WHERE id = ?', [reviewId]);

                res.json({ "message": "deleted" });
            });
        });
    });

    // Update review (only owner can edit)
    app.patch('/api/reviews/:id', (req, res) => {
        const reviewId = req.params.id;
        const userId = req.headers['x-user-id'];
        const { category, message } = req.body;

        if (!userId) {
            return res.status(401).json({ "error": "Unauthorized" });
        }

        // Check ownership
        pool.query('SELECT user_id FROM reviews WHERE id = ?', [reviewId], (err, rows) => {
            if (err) return res.status(500).json({ "error": err.message });
            if (rows.length === 0) return res.status(404).json({ "error": "Review not found" });

            if (String(rows[0].user_id) !== String(userId)) {
                return res.status(403).json({ "error": "–í—ã –º–æ–∂–µ—Ç–µ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å —Ç–æ–ª—å–∫–æ —Å–≤–æ–∏ –æ—Ç–∑—ã–≤—ã" });
            }

            pool.query('UPDATE reviews SET category = ?, message = ? WHERE id = ?', [category, message, reviewId], (err) => {
                if (err) return res.status(500).json({ "error": err.message });
                res.json({ "message": "updated" });
            });
        });
    });

    // Delete review (only owner can delete)
    app.delete('/api/reviews/:id', (req, res) => {
        const reviewId = req.params.id;
        const userId = req.headers['x-user-id'];

        if (!userId) {
            return res.status(401).json({ "error": "Unauthorized" });
        }

        // Check ownership
        pool.query('SELECT user_id FROM reviews WHERE id = ?', [reviewId], (err, rows) => {
            if (err) return res.status(500).json({ "error": err.message });
            if (rows.length === 0) return res.status(404).json({ "error": "Review not found" });

            if (String(rows[0].user_id) !== String(userId)) {
                return res.status(403).json({ "error": "–í—ã –º–æ–∂–µ—Ç–µ —É–¥–∞–ª—è—Ç—å —Ç–æ–ª—å–∫–æ —Å–≤–æ–∏ –æ—Ç–∑—ã–≤—ã" });
            }

            pool.query('DELETE FROM reviews WHERE id = ?', [reviewId], (err) => {
                if (err) return res.status(500).json({ "error": err.message });
                res.json({ "message": "deleted" });
            });
        });
    });

    bot.onText(/\/start/, (msg) => {
        const chatId = msg.chat.id;
        bot.sendMessage(chatId, 'üëã –ü—Ä–∏–≤–µ—Ç! –≠—Ç–æ –±–æ—Ç –æ–±—â–µ–∂–∏—Ç–∏—è.\n\n–ó–¥–µ—Å—å –º–æ–∂–Ω–æ:\nüéÆ –ó–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞—Ç—å PS –∑–æ–Ω—É\nüì¢ –°–æ–∑–¥–∞—Ç—å —Å–±–æ—Ä (–Ω–∞–ø—Ä–∏–º–µ—Ä, –ø–æ–∏–≥—Ä–∞—Ç—å –≤ —Å–Ω–µ–∂–∫–∏)', {
            reply_markup: {
                inline_keyboard: [[
                    {
                        text: 'üöÄ –û—Ç–∫—Ä—ã—Ç—å –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ',
                        web_app: { url: "https://nonapparent-granophyric-laylah.ngrok-free.dev" }
                    }
                ]]
            }
        });
    });

    app.listen(PORT, () => {
        console.log(`Server running on http://localhost:${PORT}`);
    });
